-------------------- Основные Команды --------------------

docker run hello-world					| Проверка работосопобности Docker путем pull'а

docker run						| СОЗДАНИЕ контейнера : <-d> возвращает сразу консоль, не дожидаясь окончания работы
							| <--rm> после остановки контейнера ---> удаляет его; --name указываем имя контейнеру

docker ps						| Docker процессы (активные) : <-a> показывает все контейнеры

docker rm c6						| Удаляем контейнер с ID c6ea97...

docker system prune -a --volumes			| Удаляет абсолютно все (важно заметить, что касаемо контейнеров только остановленные удаляет)

docker images						| Docker образ	: <rmi> удаляет образ

Alpine часто используют для построения других образов ( docker pull alpine:latest )

docker start						| ЗАПУСКАЕТСЯ контейнер (который уже созданный)

docker pause c6		/	docker unpause c6	| Приостановить / возобновить работу контейнера

docker stop c6						| Остановить полностью работу контейнера

docker kill c6						| Убить контейнер

docker exec -it c6 /bin/bash 					| Позволяет зайти в контейнер интерактивно

			# Полезная инфа
docker inspect c6					| Вся информация по контейнеру

docker stats						| Ресурсы потребляемые контейнерами

docker logs c6						| Смотрим logs программы : <-f> показывает актуальные логи

!!! docker run -d --rm --name My-Container ubuntu:20.04 echo "Hello Docker"

-------------------- Управление портами: Port Mapping --------------------

docker run -p 8080:80 nginx				| Порт 80 открыт только в контейнере, но этой командой мы его пробрасываем также на сервер
							| Таким образом теперь можно подключиться к серверу с портом 8080, и сервер направит на nginx

Обычно требуемые порты пишутся в документации к образу на DockerHub

-------------------- Переменные в Docker: Environmental Variables --------------------

docker run --name DB-mysql -e MYSQL_ROOL_PASSWORD=pw1234 -e HEHE=hehe -d mysql	| Передаем переменную контейнеру (важно понимать, что юзер тут - root)
docker exec -it DB-mysql /bin/bash
> env							| Показывает системные переменные
> mysql -p						| Вход в MySQL при помощи этой системной переменной

docker exec -it DB-mysql mysql -uroot -p		| То же самое :)

-------------------- Постоянные данные: Docker Volumes --------------------

docker volume ls					| Без volumes после убийства контейнера ---> все измененные данные исчезнут

docker volume create infos				| Создание volume с именем infos ( /var/lib/docker/ )

docker volume rm infos					| Удаление volume с именем infos

Host Volumes	|	Anonymous Volumes	|	Named Volumes

### Host Volumes
mkdir /opt/nginx
mkdir /opt/nginx/data
docker run --name web01 -p 80:80 -v /opt/nginx/data:/usr/share/nginx/html -d nginx	| Показываем откуда брать данные для nginx (их нужно создать)

### Anonymous Volumes - Хрень короче, дата еще и удалится потом. НЕ ЮЗАТЬ!!!
cd /var/lib/docker/
cd volumes
docker run --rm --name web01 -p 80:80 -v /usr/share/nginx/html -d nginx		| Неудобно, что название volumes не задается, а hash

### Names Volumes
docker run --name web01 -p 80:80 -v web_data:/usr/share/nginx/html -d nginx	| Даем имя создавшемуся volume ( /var/lib/docker/ )

-------------------- Сети в Docker: Network --------------------

docker network create --drive bridge NAME		| Создание сети типа bridge : --drive позволяет задавать тип сети (по дефолту bridge)

docker run --net myNAME nginx				| Запуск сети

docker network ls					| Показывает все сети

Создавать больше 1 сети host или none НЕЛЬЗЯ

docker network inspect NAME				| Показывает настройки сети

docker network create -d bridge --subnet 192.168.10.0/24 --gateway 192.168.10.1 myNet192

docker network rm myNet192 myNet01			| Удаление сетей по имени

docker run --rm -it --name container1 --net myNet01 nicolaka/netshoot /bin/bash
							| Запускаем именной контейнер в своей именной сети, чтобы появилась возможность DNS
							| Иначе без указания --net нельзя будет обращаться по доменному имени

docker network connect myNet01 container2		| Подключение к сети

docker network disconnect IDсети container2		| Отключение от сети 

-------------------- Создание своих контейнеров. Dockerfile --------------------

Dockerfile
{
  FROM ubuntu:22.04					| Базовый образ
  Label author=tdotv					| Описание образа
  
  RUN apt-get update
  RUN apt-get install nginx -y				| Команды P.S. Для удаления кэша дляя команд по установке
  							| APT: ... && rm -rf /var/cache/apt
  							| APK: ... && rm -rf /etc/apk/cache
  							| YUM: ... && rm -rf /var/cache/yum
  							| DNF: ... && rm -rf /var/cache/dnf
  
  !!! Важно заметить, что таким образом для скачивания nginx создается 2 слоя, вместо этого лучше использовать:
  RUN apt-get update && apt-get install nginx -y \ 
  	htop \
  	tree \ 
  	mc						| Таким образом создаем один слой и скачиваем сразу несколько пакетов
  
  WORKDIR /var/www/html/				| Рабочие директории
  
  COPY files2/index.html
  COPY files2/script.sh /opt/script.sh			| Файлы
  
  RUN chmod +x /opt/script.sh				| Работа с файлами
  
  ENV OWNER="tdotv"
  ENV TYPE=demo						| Указание переменных
  
  EXPOSE 80						| Порты (ничего не делает для образа, носит инф. контекст)
  
  ENTRYPOINT ["echo"]
  CMD ["Hello my FIRST Docker"]				| Описание команд при запуске контейнера : CMD ["echo","Hi"] 
}

docker build -t myImage:v01 .				| Создание образа

=====================================
{
  RUN apt-get install nginx -y
  CMD ["nginx","-g","daemon off;"]
}

docker run -d --rm --name mydocker -p 80:80 myimagex:v01
=====================================
































