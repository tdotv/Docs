---------- CLR via c# 4 ----------

Управляемая куча, помимо устранения ошибок, также предоставляет простую модель программирования: выделить и инициализировать ресурс и использовать его по своему усмотрению. Для большинства типов нет необходимости очищать есурс и сборщик мусора освободит память.

Среда CLR требует, чтобы все объекты были выделены из управляемой кучи. При инициализации процесса среда CLR выделяет область адресного пространства для управляемой кучи. Среда CLR также поддерживает указатель, который я назову NextObjPtr. Этот указатель указывает, где в куче должен быть размещен следующий объект. Изначально для NextObjPtr задается базовый адрес области адресного пространства.

Память приложения ограничена виртуальным адресным пространством процесса.
В 32-бит процессе - 1,5 ГБ
В 64-бит процессе - 8 ТБ

Вообщем CLR распологает объекты рядом с друг другом в памяти, что обеспечивает превосходнюу скорость благодаря локальности. ЦП сможет выполнять большинство своих манипуляций без промахов кэша, которые могли бы привести к более медленному доступу к оперативной памяти. Это, конечно, хорошо, если память бесконечная. Для решения проблем с переполнением памяти есть Garbage Collector (GC)

Из-за проблемы с алгоритмами сборщика мусора с подсчетом ссылок среда CLR вместо этого использует алгоритм отслеживания ссылок. Алгоритм отслеживания ссылок заботится только о переменных ссылочного типа, потому что только эти переменные могут ссылаться на объект в куче. Все переменные ссылочного типа называются корнями (static и instance в классе, аргументах или локальных переменных метода)

Когда среда CLR запускает сборку мусора, она приостанавливает все потоки, чтобы эти же самые потоки не обращались к объектам и не изменяли их состояние. Затем среда CLR выполняет фазу маркировки мусора: он проходит по всем объектам в куче, устанавливая бит равным 0. Это означает, что все объекты должны быть удалены. Затем среда CLR просматривает все активные корни, чтобы узнать, на какие объеты они ссылаются. (это то, что делает сборщик мусора для отслеживания ссылок). Если корень ссылается на объект (не null), то она устанавливает бит в индексе блока синхронизации объекта равным 1.

После завершения куча содержит неоторые помеченные и некоторые непомеченные объекты. Помеченные объекты должны пережить коллекцию, а непомеченные объекты недоступны, потому что в приложении нет корня, который позволил бы когла-либо снова получить доступ к объекту.
Теперь, когда среда CLR знает, какие объекты должны сохраниться, а какие нет, она приступает к фазе сжатия сборки мусора. То есть все уцелевшие объекты буду находиться рядом друг с другом в памяти И все свободное пространство также является непрерывным.

При сжатии памяти среда CLR перемещает объекты в памяти. Это проблема, потому что любой корень, которые ссылается на уцелевший объект, теперь ссылается на то место, где этот объект находился в памяти; не туда, куда был перемещен объект. Очевидно, что этого нельзя допустити, и поэтому на этапе сжатия среда вычитает из каждого корня то количество байтов, на которое ссылается объект, сдвинутый вниз в памяти.

!!! Лучше избегать статических полей, когда это возможно (статическое поле хранит любой объект, на который оно ссылается, вечно или до тех пор, пока не будет выгружен AppDomain, в который загружаются типы. Если статическое поле ссылается на объект коллекции, то статическое поле поддерживает активность объекта коллекции, а объект коллекции сохраняет активными свои элементы, ЧТО ПРИВОДИТ К УТЕЧКЕ ПАМЯТИ)

При инициализации CLR выбирает размер бюджета (в килобайтах) для поколения 0. Таким образом, если выделение нового объекта приводит к тому, что поколение 0 превысит свой бюджет, должна начаться сборка мусора.

После освобождения памяти выжившие объекты перемещаются в поколение 1, которое тоже имеет свой размер. Когда поколение 1 переполнится начнется его очистка, после чего выжившие объекты перейду в поколение 2. ВАЖНО, что все новые объекты сразу помещаются в поколение 0.

Всего есть 3 поколения: поколение 0, поколение 1, поколение 2. || Сборщик мусора может динамически изменять бюджет поколений

---- Большие объекты
Большие объекты - 85000 байт или больше по рамеру. Они не размещаются в адресном пространстве процессора

Большие объекты сразу считаются частью поколения 2; они никогда не находятся в поколении 0 или 1. Обычно большие объекты представляют собой большие строки (XML, JSON) или массивы байтов

---- GC режимы (моды)
Workstation - оптимизированный режим client-side для сборки мусора. Подразумевает, что на компьюетере запущены другие приложения, и не потребляет ресурсы процессора
Server - оптимизированный режим для server-side приложения. Подразумевает, что на компьютере не запущены другие приложения, и предполагается, что все прцоессоры на компьютере свободны. GC в этом режиме разбивает управляемую кучу на несколько секций, по одной на каждый процессор. Каждый поток собирает свою секцию параллельно с другими потоками

Symbold Defined by the GCLatencyMode Enumerated Type
<bold> Symbol Name					<bold> Description

Batch (default for server GC mode)			Turns off the concurrent GC (параллельность)
Interactive (default for workstation GC Mode)		Turns on the concurrent GC

LowLatency						Использовать этот режим задержки для краткосрочных, чувствительных ко времени операций
							(например, отрисовка анимаций), когда сборка коллекции поколения 2 может нарушить работу
							
SustainedLowLatency					Исполльзовать его, чтобы избежать длительных пауз GC в течение большей части выполнения
							приложения. Он предотвращает выполнение всех блокирующих сборок поколения 2 до тех пор, пока
							доступна память. Примером такого рода является приложение фондового рынка (немедленно)
							

Symbols Defined by the GCCollectionMode Enumerated Type
<bold> Symbol Name				<bold> Description

Default						GC.Collect with no flag

Forced						Принудительно выполняет сборку немедленно для всех поколений до указанного 
						поколения включительно
						
Optimized					Сборщик мусора выполнит сборку только в том случае, если сборка будет продуктивной за счет
						освобождения большого объема памяти, либо за счет уменьшения фрагментации. Если сборка не будет
						продуктивной, то вызов не будет иметь никакого эффекта

!!! В большинстве случаев следует избегать вызова любого из методов Collect; лучше всего просто позволить сборщику мусора работать по своему желанию

~525 - Базовые знания о работе CLR с памятью

Если тип, оборачивающий машинный ресурс, получает сборку мусора, то сборка мусора освобождает память, используемую объектом в управляемой куче; но родной ресурс, о котором GC ничего не знает будет утечка (например работа с файлами System.IO.FileStream). Очевидно, что это нежелательно, поэтому среда CLR предлагает механизм называемый finalization. Финализация позволяет объекту выполнить некоторый код после того, как объект был определен как мусор, но до того, как память будет освобождена из управляемой кучи.

!!! Следует избегать определения finalize объектов с помощью полей ссылочного, потому что когда эти объекты повышаются (окончательный объект Finalize может обратиться к полю, поэтому он должен пережить коллекцию и перейти в другое поколение, заставляя объект жить намного дольше), любой объект, на который ссылаются его поля, также повышается, потому что он тоже должен продолжать существовать. ДА И ВООБЩЕ Finalize СЛЕДУЕТ ИЗБЕГАТЬ.

Луше использовать классы, производные от SafeHandle, чтобы работать с родными ресурсами объектов.

!!! При определении собственного типа, реализующего интерфейс IDisposable, обязательно следует написать во всех методах и свойствах код для вызова исключения System.ObjectDisposedException, если объект был явно очищен. ДА И ВООБЩЕ ИСПОЛЬЗОВАТЬ Dispose СЛЕДУЕТ ИЗБЕГАТЬ (только если точно не уверен, что этот ресурс не понадобится, как в примере с попыткой удалить открытый файл)


---------- Cancellation Token ----------
CancellationTokenSource - This is the object responsible for creating a cancellation token and sending a cancellation request to all copies of that token.
CancellationToken - This is the structure used by listeners to monitor the token’s current state.

Вызываем метод CancellationTokenSource.Cancel(), который устанавливает для свойства CancellationToken.IsCancellationRequested значение true. Стоит понимать, что сам по себе метод CancellationTokenSource.Cancel() не отменяет задачу, он лишь посылает уведомление об отмене через установку свойства CancellationToken.IsCancellationRequested. Каким образом будет происходить выход из задачи, это решает сам разработчик.
Класс CancellationTokenSource реализует интерфейс IDisposable. И когда работа с объектом CancellationTokenSource завершена, у него следует вызвать метод Dispose для освобождения всех связанных с ним используемых ресурсов. (Вместо явного вызова метода Dispose можно использовать конструкцию using).
Есть 2 варианта отмены задачи: return -> TaskStatus.RanToCompletion, а не TaskStatus.Canceled; и сгенерировать исключение OperationCanceledException

---------- DDD ----------
public class Book
{
    public const int PromotionalTextLength = 200;
 
    public int BookId { get; private set; }          
    //… all other properties have a private set
 
    //These are the DDD aggregate propties: Reviews and AuthorLinks || IEnumerable!!!
    public IEnumerable<Review> Reviews => _reviews?.ToList();
    public IEnumerable<BookAuthor> AuthorsLink => _authorsLink?.ToList();
 
    //private, parameterless constructor used by EF Core
    private Book() { } 
 
    //public constructor available to developer to create a new book
    public Book(string title, string description, DateTime publishedOn, 
        string publisher, decimal price, string imageUrl, ICollection<Author> authors)
    {
        //code left out 
    }
 
    //now the methods to update the book’s properties
    public void UpdatePublishedOn(DateTime newDate)…
    public IGenericErrorHandler AddPromotion(decimal newPrice, string promotionalText)…               
    public void RemovePromotion()…
 
    //now the methods to update the book’s aggregates 
    public void AddReview(int numStars, string comment, string voterName, DbContext context)…
    public void RemoveReview(Review review)…                        
}

---------- Interface and Abstraction ----------
В статье “Towards Better Abstractions” Seemann подчеркивает, что хорошая абстракция должна:

1. Скрывать детали реализации: Пользователи абстракции не должны знать, как она работает внутри.
2. Быть легко заменяемой: Абстракция должна позволять легко заменять одну реализацию другой.
3. Поддерживать композицию: Хорошие абстракции должны легко комбинироваться с другими абстракциями.

В статье “Interfaces Are Not Abstractions” Seemann утверждает, что интерфейсы сами по себе не являются абстракциями. Вот ключевые моменты:

1. Интерфейсы как контракты: Интерфейсы определяют контракты, но не обязательно абстракции. Они описывают, что класс должен делать, но не как это делать.
2. Принцип разделения интерфейсов (ISP): Создание небольших, специализированных интерфейсов помогает избежать “жирных” интерфейсов, которые сложно поддерживать и использовать.
3. Композиция вместо наследования: Seemann рекомендует использовать композицию для создания гибких и легко изменяемых систем, вместо жесткого наследования.

Примеры
- Composite Pattern: Этот паттерн позволяет создавать иерархии объектов, где каждый объект может быть как простым, так и составным. Интерфейс в этом случае служит хорошей абстракцией, так как позволяет работать с объектами единообразно.
- Null Object Pattern: Этот паттерн предоставляет объект, который ничего не делает, но соответствует интерфейсу. Это позволяет избежать проверок на null и упрощает код.

---------- Assembly and Reflection ----------
c# -> IL -> упаковка в упр. модуль с назв. PE32 -> ASM -> машинный код
PE32 состоит из:
1. Заголовок PE32 или PE32+
2. Заголовок CLR
3. IL код
4. метаданные

Метаданные - описание того, что хравнится в модуле: всех сущностях, всех методов, а также ссылки на другие модули. 
Верифицируемость - гарантия того, что код будет исправно работать с памятью. IL код верифицируем.

just in time (JIT) компилятор компилирует Intermediate Language (IL). JIT компиляция происходит в тот момент, когда обращаемся к вызову (например, методу)

Assembly состоит из 
1. IL 
2. metadata

Домен - область, в которой выполняется код
1. AppDomain - это изолированная среда для выполнения кода в приложении .NET. Каждый AppDomain может загружать свои сборки, выполнять код и иметь свои настройки.
Это позволяет изолировать процессы, что повышает безопасность и стабильность приложений
2. Domain может ссылать на область памяти или ресурсы, с которыми работает код

Assembly Load(string) вызывает CLR, чтобы найти assembly. Есть также System.AppDomain Load(), но он перепишет поведение CLR, чтобы он исп. настройки AppDomain
Assembly Unload нет, т.к. после возвращения к методу, будет ошибка

Reflection - сильный инструмент для обнаружения и использования types и members во время выполнения.
1. Рефлекция обеспечивает сохранность типизации во время компилирования.
2. Рефлекция медленная. Имена типов и их members неизвестны во время компилирования; они узнаются во время run time при помощи string search.
! По сути Reflection - это пространство имен для организации классов, интерфейсов и делегатов. Позволяет писать код, который отражает метаданные, хранящ. в таблицах
Позволяет делать запрос к типу поля, методам, свойствам

---------- Attributes ----------
Атрибуты - метаданные, который позволяет встраивать в сборку доп. метаданные; Можно использовать для сериализации и десериализации. Ну по сути внутри у них класс.

---------- Async ----------
Асинхронность - когда поток не задерживается на конкретном месте, ему не надо ожидать ответа от какой-то долгосрочной операции.
Ключевое слово async - модифицирует метод и возвращает объект типа Task или Task<T>
Ключевое слово await - приостанавливает выполнение метода до завершения асинхронной операции

Например, работа с БД. Т.к. работа с данными выполняется со стороны БД, а не программы. Вот первый поток пошел дальше, и потом другой первый попавшийся
поток похватит и закончит эту работу. 
! Не значит, что один и тот же поток как начал, так и закончил.

ConfigureAwait(true): запускает оставшуюся часть кода в том же потоке, который был запущен до await.
!!! НЕ ОБЯЗАТЕЛЬНО в том же потоке, но в том же контексте async. Контекст async удет определять как запустить код. Обычно в UI этот тот же поток,
однако в ASP.NET это может быть не тот же поток, но он предоставит HttpContext

ConfigureAwait(false): говорит, что не нужен контекст, поэтому код может выполняться в любом потоке

ConfigureAwait(true) стоит по умолчанию. Производительность не падает, хоть и нужно вызывать контекст.
ConfigureAwait(false) лучше НЕ использовать, потому что обычно ждешь обычное поведение от программы.






