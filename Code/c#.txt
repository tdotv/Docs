---------- CLR via c# ----------
Управляемая куча, помимо устранения ошибок, также предоставляет простую модель программирования: выделить и инициализировать ресурс и использовать его по своему усмотрению. Для большинства типов нет необходимости очищать есурс и сборщик мусора освободит память.

Среда CLR требует, чтобы все объекты были выделены из управляемой кучи. При инициализации процесса среда CLR выделяет область адресного пространства для управляемой кучи. Среда CLR также поддерживает указатель, который я назову NextObjPtr. Этот указатель указывает, где в куче должен быть размещен следующий объект. Изначально для NextObjPtr задается базовый адрес области адресного пространства.

Память приложения ограничена виртуальным адресным пространством процесса.
В 32-бит процессе - 1,5 ГБ
В 64-бит процессе - 8 ТБ

Вообщем CLR распологает объекты рядом с друг другом в памяти, что обеспечивает превосходнюу скорость благодаря локальности. ЦП сможет выполнять большинство своих манипуляций без промахов кэша, которые могли бы привести к более медленному доступу к оперативной памяти. Это, конечно, хорошо, если память бесконечная. Для решения проблем с переполнением памяти есть Garbage Collector (GC)

Из-за проблемы с алгоритмами сборщика мусора с подсчетом ссылок среда CLR вместо этого использует алгоритм отслеживания ссылок. Алгоритм отслеживания ссылок заботится только о переменных ссылочного типа, потому что только эти переменные могут ссылаться на объект в куче. Все переменные ссылочного типа называются корнями (static и instance в классе, аргументах или локальных переменных метода)

Когда среда CLR запускает сборку мусора, она приостанавливает все потоки, чтобы эти же самые потоки не обращались к объектам и не изменяли их состояние. Затем среда CLR выполняет фазу маркировки мусора: он проходит по всем объектам в куче, устанавливая бит равным 0. Это означает, что все объекты должны быть удалены. Затем среда CLR просматривает все активные корни, чтобы узнать, на какие объеты они ссылаются. (это то, что делает сборщик мусора для отслеживания ссылок). Если корень ссылается на объект (не null), то она устанавливает бит в индексе блока синхронизации объекта равным 1.

После завершения куча содержит неоторые помеченные и некоторые непомеченные объекты. Помеченные объекты должны пережить коллекцию, а непомеченные объекты недоступны, потому что в приложении нет корня, который позволил бы когла-либо снова получить доступ к объекту.
Теперь, когда среда CLR знает, какие объекты должны сохраниться, а какие нет, она приступает к фазе сжатия сборки мусора. То есть все уцелевшие объекты буду находиться рядом друг с другом в памяти И все свободное пространство также является непрерывным.

При сжатии памяти среда CLR перемещает объекты в памяти. Это проблема, потому что любой корень, которые ссылается на уцелевший объект, теперь ссылается на то место, где этот объект находился в памяти; не туда, куда был перемещен объект. Очевидно, что этого нельзя допустити, и поэтому на этапе сжатия среда вычитает из каждого корня то количество байтов, на которое ссылается объект, сдвинутый вниз в памяти.

!!! Лучше избегать статических полей, когда это возможно (статическое поле хранит любой объект, на который оно ссылается, вечно или до тех пор, пока не будет выгружен AppDomain, в который загружаются типы. Если статическое поле ссылается на объект коллекции, то статическое поле поддерживает активность объекта коллекции, а объект коллекции сохраняет активными свои элементы, ЧТО ПРИВОДИТЬ К УТЕЧКЕ ПАМЯТИ)


